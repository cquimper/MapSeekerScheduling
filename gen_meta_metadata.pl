% Purpose: Compute meta metadata from the metadata in order to find:
%  . size (maximum number of vertices) from which we acquire conjectures (as want to use the smallest possible size for which reached fixed point)
% Author : Nicolas Beldiceanu, IMT Atlantique

:- use_module(library(lists)).
:- use_module(library(clpfd)).
:- use_module(tables).
:- use_module(table_access).
:- use_module(utility).
:- use_module(gen_candidate_tables).

top(KindCombi, MaxNbVertices) :- % compute fixpoint information from all sizes of the different tables
    MaxNbVertices > 0,
    atoms_concat(['data/',KindCombi,'/meta_metadata_',KindCombi,'.pl'], % create a specific meta metadata
                 FileName),                                             % file for each combinatorial object
    open(FileName, write, Sout),
    format(Sout, '% Purpose: Meta metadata generated by gen_meta_metadata.pl in order to select which size to use when acquiring a conjecture:~n', []),
    format(Sout, '%          generate facts of the following form~n', []),
    format(Sout, '%           size_to_compute_conjectures(Table, FixPointSize, SizeToUse, NbRowsSizeToUse)~n', []),
    format(Sout, '% Author : Nicolas Beldiceanu, IMT Atlantique~n~n', []),
    format(Sout, ':- dynamic size_to_compute_conjectures/4.~n~n', []),
    gen_meta_metadata(KindCombi, MaxNbVertices, Sout),
    close(Sout).

top(KindCombi, MinusMaxNbVertices, MinNParam, MaxNParam) :-             % show interesting information from computed meta-data
    MinusMaxNbVertices < 0,
    MaxNbVertices is -MinusMaxNbVertices,
    NParam in MinNParam..MaxNParam,                                       % modif
    indomain(NParam),                                                     % modif
    gen_candidate_tables(Functor, KindCombi, _KindBound, _Bound, NParam), % modif
    consult_metadata(KindCombi, MaxNbVertices, MaxNbVertices, Functor),
    extract_interesting_metadata(Functor),
    false.
top(_, _, _, _).

extract_interesting_metadata(Functor) :-
    get_metadata_arity(Arity),
    get_metadata_attributes(IndexNames),
    functor(TableMetaData, table_metadata, Arity),
    memberchk(IndTableName-table_name,  IndexNames),
    memberchk(IndNbColumns-nb_columns,  IndexNames),
    memberchk(IndNbRows-nb_rows,        IndexNames),
    memberchk(IndNames-col_names,       IndexNames),
    memberchk(IndKinds-kinds,           IndexNames),
    memberchk(IndMins-mins,             IndexNames),
    memberchk(IndMaxs-maxs,             IndexNames),
    memberchk(IndTypes-types,           IndexNames),
    memberchk(IndNvals-nvals,           IndexNames),
    memberchk(IndGcds-gcds,             IndexNames),
    memberchk(IndMaxoccs-maxoccs,       IndexNames),
    memberchk(IndMaxoccvals-maxoccvals, IndexNames),
    memberchk(IndPks-pks,               IndexNames),
    memberchk(IndAffinities-affinities, IndexNames),
    arg(IndTableName,  TableMetaData, Functor),
    arg(IndNbColumns,  TableMetaData, NbColumns),
    arg(IndNbRows,     TableMetaData, NbRows),
    arg(IndNames,      TableMetaData, Names),
    arg(IndKinds,      TableMetaData, Kinds),
    arg(IndMins,       TableMetaData, Mins),
    arg(IndMaxs,       TableMetaData, Maxs),
    arg(IndTypes,      TableMetaData, Types),
    arg(IndNvals,      TableMetaData, Nvals),
    arg(IndGcds,       TableMetaData, Gcds),
    arg(IndMaxoccs,    TableMetaData, Maxoccs),
    arg(IndMaxoccvals, TableMetaData, Maxoccvals),
    arg(IndPks,        TableMetaData, Pks),
    arg(IndAffinities, TableMetaData, Affinities),
    call(TableMetaData),
    (Pks = [] ->
%        findall(I, (I in 1..NbColumns, indomain(I), arg(I, Kinds, primary)), Params),
%        length(Params, NParams),
%        write(Functor), write(' no primary key'), write(' (nb_params='), write(NParams), write('):'), nl, nl
        true
    ;
        true
    ),
    NbRows9 is NbRows - NbRows // 9,
    findall(t(Name,Maxocc,Maxoccval), (I in 1..NbColumns, indomain(I),
                                       arg(I, Names, Name),
                                       arg(I, Types, bool),
                                       arg(I, Kinds, Kind), Kind \= primary,
                                       arg(I, Maxoccs, Maxocc),
                                       Maxocc >= NbRows9,
                                       arg(I, Maxoccvals, Maxoccval)), MeaningfullBool),
    (MeaningfullBool = [] ->
        true
    ;
      write(Functor), write(' meaningfull Boolean value'), write(' (nb_rows='), write(NbRows), write('):'), nl,
      write(MeaningfullBool), nl, nl
    ),
    findall(t(Name,Min,Max), (I in 1..NbColumns, indomain(I),
                              arg(I, Names, Name),
                              arg(I, Types, int),
                              arg(I, Kinds, Kind), Kind \= primary,
                              arg(I, Nvals, 2),
                              arg(I, Mins,  Min),
                              arg(I, Maxs,  Max),
                              Range is Max-Min+1,
                              Range = 2), MeaningfullVals2),
    (MeaningfullVals2 = [] ->
        true
    ;
      write(Functor), write(' two values but not Boolean:'), nl,
      write(MeaningfullVals2), nl, nl
    ),
    findall(t(Name,Min,Max), (I in 1..NbColumns, indomain(I),
                              arg(I, Names, Name),
                              arg(I, Types, int),
                              arg(I, Kinds, Kind), Kind \= primary,
                              arg(I, Nvals, 3),
                              arg(I, Mins,  Min),
                              arg(I, Maxs,  Max),
                              Range is Max-Min+1,
                              Range = 3), MeaningfullVals3),
     (MeaningfullVals3 = [] ->
        true
    ;
      write(Functor), write(' three values:'), nl,
      write(MeaningfullVals3), nl, nl
    ),
    findall(t(Name,Min,Max), (I in 1..NbColumns, indomain(I),
                              arg(I, Names, Name),
                              arg(I, Types, int),
                              arg(I, Kinds, Kind), Kind \= primary,
                              arg(I, Nvals, 4),
                              arg(I, Mins,  Min),
                              arg(I, Maxs,  Max),
                              Range is Max-Min+1,
                              Range = 4), MeaningfullVals4),
     (MeaningfullVals4 = [] ->
        true
    ;
      write(Functor), write(' four values:'), nl,
      write(MeaningfullVals4), nl, nl
    ),
    NbRows2 is NbRows // 2,
    findall(t(I,Maxocc,Maxoccval), (I in 1..NbColumns, indomain(I),
                                    arg(I, Types, int),
                                    arg(I, Kinds, Kind), Kind \= primary,
                                    arg(I, Maxoccs, Maxocc),
                                    Maxocc >= NbRows2, arg(I, Maxoccvals, Maxoccval)), MeaningfullMaxoccs),
    (MeaningfullMaxoccs = [] ->
        true
    ;
%        write(Functor), write(' (nb_rows='), write(NbRows), write('):'), nl,
%        write(MeaningfullMaxoccs), nl, nl
        true
    ),
    findall(I-Gcd, (I in 1..NbColumns, indomain(I),
                    arg(I, Gcds, Gcd),
                    Gcd > 1                       ), MeaningfullGcds),
    (MeaningfullGcds = [] ->
        true
    ;
%        write(Functor), write(':'), nl,
%        write(MeaningfullGcds), nl, nl
        true
    ),
    findall(I-Affinity, (I in 1..NbColumns, indomain(I),
                         arg(I, Affinities, Affinity),
                         Affinity \= none              ), MeaningfullAffinities),
    (MeaningfullAffinities = [] ->
        true
    ;
%        write(Functor), write(' (nb_rows='), write(NbRows), write('):'), nl,
%        write(MeaningfullAffinities), nl, nl
        true
    ).

gen_meta_metadata(KindCombi, MaxNbVertices, Sout) :-
    get_metadata_arity(Arity),                              % get arity of a metadata fact
    get_tables(KindCombi, _, _, _, Tables),                 % get all tables
    sort(Tables, SortedTables),                             % remove duplicates !!!
    member(Functor, SortedTables),                          % get name of next functor for which will compute meta metadata
    functor(Term, table_metadata, Arity),                   % create an "empty" table_metadata term, and use it in order to
    retractall(Term),                                       % remove all metadata facts from the previous functor
    consult_metadata(KindCombi, 2, MaxNbVertices, Functor), % consult all metadata files from current functor
    identify_fix_point_metadata(MaxNbVertices, Functor, SmallestSizeForWhichReachFixPoint),
    get_size_wrt_limits(Functor, SmallestSizeForWhichReachFixPoint, 2, MaxNbVertices, 200, 10000, init, SelectedNbRows, SelectedSize),
    format(Sout,'size_to_compute_conjectures(~w,~w,~w,~w).~n',[Functor,SmallestSizeForWhichReachFixPoint,SelectedSize,SelectedNbRows]),
    false.
gen_meta_metadata(_, _, _).

identify_fix_point_metadata(2, _, 2) :- !.
identify_fix_point_metadata(MaxN, Functor, SmallestSizeForWhichReachFixPoint) :-
    MaxN > 2,
    (check_if_not_reached_fix_point(MaxN, Functor) ->
        MaxN1 is MaxN-1,
        identify_fix_point_metadata(MaxN1, Functor, SmallestSizeForWhichReachFixPoint)
    ;
        SmallestSizeForWhichReachFixPoint = MaxN
    ).

check_if_not_reached_fix_point(MaxN, Functor) :-
    get_metadata_attributes(IndexNames),
    memberchk(IndTableName-table_name,       IndexNames),
    memberchk(IndMaxN-max_n,                 IndexNames),
    memberchk(IndNbColumns-nb_columns,       IndexNames),
    memberchk(IndTypes-types,                IndexNames),
    memberchk(IndGcds-gcds,                  IndexNames),
    memberchk(IndEquals-equals,              IndexNames),
    memberchk(IndFds-fds,                    IndexNames),
    memberchk(IndNbFds-nb_fds,               IndexNames),
    memberchk(IndCmps-cmps,                  IndexNames),
    memberchk(IndNbCmps-nb_cmps,             IndexNames),
    memberchk(IndDistinctVals-distinct_vals, IndexNames), % NEW
    memberchk(IndValsFds-vals_fds,           IndexNames), % NEW
    MaxN1 is MaxN-1,
    get_metadata_arity(Arity),
    functor(TableMetaData,     table_metadata, Arity),
    functor(TableMetaDataPrev, table_metadata, Arity),
    arg(IndTableName,    TableMetaData,     Functor),
    arg(IndTableName,    TableMetaDataPrev, Functor),
    arg(IndMaxN,         TableMetaData,     MaxN),
    arg(IndMaxN,         TableMetaDataPrev, MaxN1),
    arg(IndNbColumns,    TableMetaData,     NbColumns),
    arg(IndNbColumns,    TableMetaDataPrev, NbColumns),
    arg(IndTypes,        TableMetaData,     Types),
    arg(IndTypes,        TableMetaDataPrev, Types),
    arg(IndGcds,         TableMetaData,     Gcds),
    arg(IndGcds,         TableMetaDataPrev, Gcds),
    arg(IndEquals,       TableMetaData,     Equals),
    arg(IndEquals,       TableMetaDataPrev, Equals),
    arg(IndFds,          TableMetaData,     Fds),
    arg(IndFds,          TableMetaDataPrev, Fds),
    arg(IndNbFds,        TableMetaData,     NbFds),
    arg(IndNbFds,        TableMetaDataPrev, NbFds),
    arg(IndCmps,         TableMetaData,     Cmps),
    arg(IndCmps,         TableMetaDataPrev, Cmps),
    arg(IndNbCmps,       TableMetaData,     NbCmps),
    arg(IndNbCmps,       TableMetaDataPrev, NbCmps),
    arg(IndDistinctVals, TableMetaData,     DistinctVals), % NEW
    arg(IndDistinctVals, TableMetaDataPrev, DistinctVals), % NEW
    arg(IndValsFds,      TableMetaData,     ValsFds),      % NEW
    arg(IndValsFds,      TableMetaDataPrev, ValsFds),      % NEW
    call(TableMetaData),
    call(TableMetaDataPrev).

get_size_wrt_limits(Functor, Size, MinSize, MaxSize, MinNbRows, MaxNbRows, PrevDir, NewNbRows, NewSize) :-
    get_metadata_arity(Arity),
    get_metadata_attributes(IndexNames),
    memberchk(IndTableName-table_name, IndexNames),
    memberchk(IndMaxN-max_n,           IndexNames),
    memberchk(IndNbRows-nb_rows,       IndexNames),
    functor(TableMetaData, table_metadata, Arity),
    arg(IndTableName, TableMetaData, Functor),
    arg(IndMaxN,      TableMetaData, Size),
    arg(IndNbRows,    TableMetaData, NbRows),
    call(TableMetaData),
    NextSize is Size+1,
    PrevSize is Size-1,
    ((NbRows<MinNbRows, Size=MaxSize)               ->
        NewSize = Size, NewNbRows = NbRows                                                                      ;
     (NbRows>MaxNbRows, Size=MinSize)               ->
        NewSize = Size, NewNbRows = NbRows                                                                      ;
     (NbRows<MinNbRows, Size<MaxSize, PrevDir\=dec) ->
        get_size_wrt_limits(Functor, NextSize, MinSize, MaxSize, MinNbRows, MaxNbRows, inc, NewNbRows, NewSize) ;
     (NbRows>MaxNbRows, Size>MinSize, PrevDir\=inc) ->
        get_size_wrt_limits(Functor, PrevSize, MinSize, MaxSize, MinNbRows, MaxNbRows, dec, NewNbRows, NewSize) ;
        NewSize = Size, NewNbRows = NbRows                                                                      ).

consult_metadata(KindCombi, MinNbVertices, MaxNbVertices, Functor) :- % put here as cannot consult from a module
    MaxN in MinNbVertices..MaxNbVertices,
    indomain(MaxN),                                              % go through all the table sizes
    number_codes(MaxN, CodesMaxN),                               % convert MaxN to an atom in order to create
    atom_codes(AtomMaxN, CodesMaxN),                             % the name of the subfolder that will contain
    atoms_concat(['data/',KindCombi,                             % all metadata files corresponding to
                  '/data',                                       % combinatorial objects that have up to
                  AtomMaxN,'/',                                  % MaxN elements
                  Functor,                                       % table name
                  '_metadata.pl'], ConsultFile),                 % name of metadata file
    consult(ConsultFile),
    false.
consult_metadata(_, _, _, _).
